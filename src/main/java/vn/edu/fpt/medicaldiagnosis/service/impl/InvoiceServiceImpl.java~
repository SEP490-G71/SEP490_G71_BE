package vn.edu.fpt.medicaldiagnosis.service.impl;

import com.itextpdf.io.font.PdfEncodings;
import com.itextpdf.io.util.StreamUtil;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.spire.doc.*;
import com.spire.doc.fields.TextRange;
import jakarta.transaction.Transactional;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import vn.edu.fpt.medicaldiagnosis.common.DataUtil;
import vn.edu.fpt.medicaldiagnosis.dto.request.PayInvoiceRequest;
import vn.edu.fpt.medicaldiagnosis.dto.request.UpdateInvoiceRequest;
import vn.edu.fpt.medicaldiagnosis.dto.response.InvoiceDetailResponse;
import vn.edu.fpt.medicaldiagnosis.dto.response.InvoiceItemResponse;
import vn.edu.fpt.medicaldiagnosis.dto.response.InvoiceResponse;
import vn.edu.fpt.medicaldiagnosis.entity.*;
import vn.edu.fpt.medicaldiagnosis.enums.InvoiceStatus;
import vn.edu.fpt.medicaldiagnosis.enums.MedicalOrderStatus;
import vn.edu.fpt.medicaldiagnosis.enums.MedicalRecordStatus;
import vn.edu.fpt.medicaldiagnosis.exception.AppException;
import vn.edu.fpt.medicaldiagnosis.exception.ErrorCode;
import vn.edu.fpt.medicaldiagnosis.mapper.InvoiceMapper;
import vn.edu.fpt.medicaldiagnosis.repository.*;
import vn.edu.fpt.medicaldiagnosis.service.InvoiceService;
import vn.edu.fpt.medicaldiagnosis.specification.InvoiceSpecification;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.net.URL;
import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import java.util.List;
import java.util.Locale;

import com.spire.doc.documents.Paragraph;
import com.spire.doc.TableCell;

@Service
@Slf4j
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Transactional
public class InvoiceServiceImpl implements InvoiceService {

    InvoiceRepository invoiceRepository;
    MedicalOrderRepository medicalOrderRepository;
    MedicalRecordRepository medicalRecordRepository;
    StaffRepository staffRepository;
    InvoiceMapper invoiceMapper;
    InvoiceItemRepository invoiceItemRepository;
    MedicalServiceRepository medicalServiceRepository;
    @Override
    public InvoiceResponse payInvoice(PayInvoiceRequest request) {
        log.info("Service: pay invoice");
        // 1. Lấy invoice và kiểm tra trạng thái
        Invoice invoice = invoiceRepository.findByIdAndDeletedAtIsNull(request.getInvoiceId())
                .orElseThrow(() -> new AppException(ErrorCode.INVOICE_NOT_FOUND));

        if (InvoiceStatus.PAID.equals(invoice.getStatus())) {
            throw new AppException(ErrorCode.INVOICE_ALREADY_PAID);
        }
        // 2. Lấy thông tin thu ngân xác nhận
        Staff staff = staffRepository.findByIdAndDeletedAtIsNull(request.getStaffId())
                .orElseThrow(() -> new AppException(ErrorCode.STAFF_NOT_FOUND));
        // 3. Cập nhật invoice
        invoice.setPaymentType(request.getPaymentType());
        invoice.setStatus(InvoiceStatus.PAID);
        invoice.setConfirmedBy(staff);
        invoice.setConfirmedAt(LocalDateTime.now());
        invoiceRepository.save(invoice);
        // 4. Cập nhật trạng thái các medical order liên quan
        List<MedicalOrder> orders =
                medicalOrderRepository.findAllByInvoiceItemInvoiceId(invoice.getId());
        Set<MedicalRecord> relatedRecords = new HashSet<>();

        for (MedicalOrder order : orders) {
            order.setStatus(MedicalOrderStatus.WAITING);
            relatedRecords.add(order.getMedicalRecord());
        }
        medicalOrderRepository.saveAll(orders);

        // 5. Cập nhật trạng thái của 1 medical record duy nhất
        if (relatedRecords.isEmpty()) {
            throw new AppException(ErrorCode.MEDICAL_RECORD_NOT_FOUND);
        }

        if (relatedRecords.size() > 1) {
            throw new AppException(ErrorCode.MULTIPLE_MEDICAL_RECORDS_FOUND);
        }

        MedicalRecord record = relatedRecords.iterator().next();
        record.setStatus(MedicalRecordStatus.TESTING);
        medicalRecordRepository.save(record);
        log.info("Invoice {} has been marked as PAID by staff {}", invoice.getId(), staff.getId());

        return invoiceMapper.toInvoiceResponse(invoice);
    }

    @Override
    public Page<InvoiceResponse> getInvoicesPaged(Map<String, String> filters, int page, int size, String sortBy, String sortDir) {
        String sortColumn = (sortBy == null || sortBy.isBlank()) ? "createdAt" : sortBy;
        Sort sort = sortDir.equalsIgnoreCase("asc") ? Sort.by(sortColumn).ascending() : Sort.by(sortColumn).descending();
        Pageable pageable = PageRequest.of(page, size, sort);

        Specification<Invoice> spec = InvoiceSpecification.buildSpecification(filters);
        Page<Invoice> pageResult = invoiceRepository.findAll(spec, pageable);

        return pageResult.map(invoiceMapper::toInvoiceResponse);
    }

    @Override
    public InvoiceResponse updateInvoiceItems(UpdateInvoiceRequest request) {
        log.info("Service: update invoice items (smart diff)");

        Invoice invoice = invoiceRepository.findByIdAndDeletedAtIsNull(request.getInvoiceId())
                .orElseThrow(() -> new AppException(ErrorCode.INVOICE_NOT_FOUND));

        if (InvoiceStatus.PAID.equals(invoice.getStatus())) {
            throw new AppException(ErrorCode.INVOICE_ALREADY_PAID);
        }

        Staff staff = staffRepository.findByIdAndDeletedAtIsNull(request.getStaffId())
                .orElseThrow(() -> new AppException(ErrorCode.STAFF_NOT_FOUND));

        // Load hiện tại
        List<InvoiceItem> currentItems = invoiceItemRepository.findAllByInvoiceId(invoice.getId());
        Map<String, InvoiceItem> currentItemMap = currentItems.stream()
                .collect(Collectors.toMap(item -> item.getService().getId(), Function.identity()));

        List<MedicalOrder> allOrders = medicalOrderRepository.findAllByInvoiceItemIdIn(
                currentItems.stream().map(InvoiceItem::getId).toList()
        );

        List<InvoiceItem> itemsToDelete = new ArrayList<>();
        List<InvoiceItem> itemsToKeep = new ArrayList<>();

        // Tổng cộng
        BigDecimal originalTotal = BigDecimal.ZERO;
        BigDecimal discountTotal = BigDecimal.ZERO;
        BigDecimal vatTotal = BigDecimal.ZERO;
        BigDecimal finalTotal = BigDecimal.ZERO;

        for (UpdateInvoiceRequest.InvoiceItemUpdateRequest newItem : request.getServices()) {
            String serviceId = newItem.getServiceId();
            int newQuantity = newItem.getQuantity();

            MedicalService service = medicalServiceRepository.findByIdAndDeletedAtIsNull(serviceId)
                    .orElseThrow(() -> new AppException(ErrorCode.MEDICAL_SERVICE_NOT_FOUND));

            BigDecimal price = service.getPrice();
            BigDecimal discountPercent = service.getDiscount() != null ? service.getDiscount() : BigDecimal.ZERO;
            BigDecimal vat = service.getVat() != null ? service.getVat() : BigDecimal.ZERO;

            BigDecimal itemOriginal = price.multiply(BigDecimal.valueOf(newQuantity));
            BigDecimal discountPerUnit = price.multiply(discountPercent).divide(BigDecimal.valueOf(100));
            BigDecimal itemDiscount = discountPerUnit.multiply(BigDecimal.valueOf(newQuantity));
            BigDecimal discounted = price.subtract(discountPerUnit);

            BigDecimal subtotal = discounted.multiply(BigDecimal.valueOf(newQuantity));
            BigDecimal itemVat = subtotal.multiply(vat).divide(BigDecimal.valueOf(100));
            BigDecimal total = subtotal.add(itemVat);


            originalTotal = originalTotal.add(itemOriginal);
            discountTotal = discountTotal.add(itemDiscount);
            vatTotal = vatTotal.add(itemVat);
            finalTotal = finalTotal.add(total);

            if (currentItemMap.containsKey(serviceId)) {
                InvoiceItem oldItem = currentItemMap.get(serviceId);
                if (oldItem.getQuantity() == newQuantity) {
                    itemsToKeep.add(oldItem);
                    continue;
                } else {
                    itemsToDelete.add(oldItem);
                }
            }

            // Tạo mới
            InvoiceItem created = invoiceItemRepository.save(InvoiceItem.builder()
                    .invoice(invoice)
                    .service(service)
                    .serviceCode(service.getServiceCode())
                    .name(service.getName())
                    .quantity(newQuantity)
                    .price(price)
                    .discount(discountPercent)
                    .vat(vat)
                    .total(total)
                    .build());

            for (int i = 0; i < newQuantity; i++) {
                medicalOrderRepository.save(MedicalOrder.builder()
                        .medicalRecord(allOrders.isEmpty() ? null : allOrders.get(0).getMedicalRecord())
                        .service(service)
                        .invoiceItem(created)
                        .createdBy(staff)
                        .status(MedicalOrderStatus.PENDING)
                        .build());
            }
        }

        // Xoá item và order không còn trong request
        for (InvoiceItem item : currentItems) {
            boolean inRequest = request.getServices().stream()
                    .anyMatch(i -> i.getServiceId().equals(item.getService().getId()));
            if (!inRequest) {
                itemsToDelete.add(item);
            }
        }

        // Xoá medical orders trước
        List<String> deleteItemIds = itemsToDelete.stream().map(InvoiceItem::getId).toList();
        List<MedicalOrder> ordersToDelete = allOrders.stream()
                .filter(order -> deleteItemIds.contains(order.getInvoiceItem().getId()))
                .toList();
        medicalOrderRepository.deleteAll(ordersToDelete);
        invoiceItemRepository.deleteAll(itemsToDelete);

        // Cập nhật lại total
        invoice.setOriginalTotal(originalTotal);
        invoice.setDiscountTotal(discountTotal);
        invoice.setVatTotal(vatTotal);
        invoice.setTotal(finalTotal);
        invoiceRepository.save(invoice);

        return invoiceMapper.toInvoiceResponse(invoice);
    }


    @Override
    public ByteArrayInputStream generateInvoicePdf(String invoiceId) {
        log.info("Service: generate invoice pdf");

        Invoice invoice = invoiceRepository.findByIdAndDeletedAtIsNull(invoiceId)
                .orElseThrow(() -> new AppException(ErrorCode.INVOICE_NOT_FOUND));

        List<InvoiceItem> items = invoiceItemRepository.findAllByInvoiceId(invoiceId);

        try {
            // === 1. Load DOCX từ Cloudinary ===
            String url = "https://res.cloudinary.com/dowftdnex/raw/upload/v1751366464/medsoft/templates/invoice_tempalte_6e1c49c9-8eb0-47e7-823f-363f14b7cebd.docx";
            Document doc = new Document();
            doc.loadFromStream(new URL(url).openStream(), FileFormat.Docx);

            Map<String, Object> invoiceData = new HashMap<>();
            invoiceData.put("INVOICE_CODE", invoice.getInvoiceCode());
            invoiceData.put("CUSTOMER_NAME", invoice.getPatient().getFullName());
            invoiceData.put("CUSTOMER_PHONE", invoice.getPatient().getPhone());
            invoiceData.put("CUSTOMER_CODE", invoice.getPatient().getPatientCode());
            invoiceData.put("PAYMENT_DATE", invoice.getConfirmedAt() != null
                    ? invoice.getConfirmedAt().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"))
                    : "-");
            invoiceData.put("CASHIER_NAME", invoice.getConfirmedBy() != null
                    ? invoice.getConfirmedBy().getFullName()
                    : "-");
            invoiceData.put("TOTAL_AMOUNT", formatCurrency(invoice.getTotal()) + " VND");
            invoiceData.put("DESCRIPTION", invoice.getDescription() != null ? invoice.getDescription() : "");

            // DÒNG QUAN TRỌNG: Sử dụng thay thế toàn bộ đoạn văn bản một cách "merge"
            DataUtil.replaceParagraphPlaceholders(doc, invoiceData);


            // === 3. Tìm đúng bảng và dòng mẫu ===
            Section section = doc.getSections().get(0);
            Table table = null;
            TableRow templateRow = null;

            outer:
            for (int t = 0; t < section.getTables().getCount(); t++) {
                Table currentTable = section.getTables().get(t);
                for (int r = 0; r < currentTable.getRows().getCount(); r++) {
                    TableRow row = currentTable.getRows().get(r);
                    for (int c = 0; c < row.getCells().getCount(); c++) {
                        String text = DataUtil.getCellText(row.getCells().get(c));
                        if (text.contains("{") && text.contains("}")) {
                            table = currentTable;
                            templateRow = row;
                            log.info("Found template row at Table {}, Row {}", t, r);
                            break outer;
                        }
                    }
                }
            }

            if (table == null || templateRow == null) {
                log.error("Không tìm thấy bảng hoặc dòng mẫu phù hợp.");
                throw new AppException(ErrorCode.INVOICE_PDF_CREATION_FAILED);
            }

            // === 4. Thêm dữ liệu vào bảng ===
            int index = 1;
            for (InvoiceItem item : items) {
                Map<String, Object> rowData = new HashMap<>();
                rowData.put("INDEX", index++);
                rowData.put("SERVICE_NAME", item.getName());
                rowData.put("SERVICE_CODE", item.getServiceCode());
                rowData.put("QUANTITY", item.getQuantity());
                rowData.put("PRICE", formatCurrency(item.getPrice()));
                rowData.put("DISCOUNT", formatCurrency(item.getDiscount()));
                rowData.put("VAT", formatCurrency(item.getVat()));
                rowData.put("TOTAL", formatCurrency(item.getTotal()));

                TableRow newRow = (TableRow) templateRow.deepClone();
                DataUtil.replaceRowPlaceholders(newRow, rowData);
                table.getRows().add(newRow);
            }

            table.getRows().remove(templateRow); // Xóa dòng mẫu

            // === 5. Export PDF ===
            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
                doc.saveToStream(out, FileFormat.PDF);
                return new ByteArrayInputStream(out.toByteArray());
            }

        } catch (Exception e) {
            log.error("Error generating invoice PDF", e);
            throw new AppException(ErrorCode.INVOICE_PDF_CREATION_FAILED);
        }
    }




    @Override
    public InvoiceDetailResponse getInvoiceDetail(String id) {
        Invoice invoice = invoiceRepository.findByIdAndDeletedAtIsNull(id)
                .orElseThrow(() -> new AppException(ErrorCode.INVOICE_NOT_FOUND));

        List<InvoiceItem> items = invoiceItemRepository.findAllByInvoiceId(invoice.getId());

        List<InvoiceItemResponse> itemResponses = items.stream().map(item -> InvoiceItemResponse.builder()
                .name(item.getName())
                .quantity(item.getQuantity())
                .serviceCode(item.getServiceCode())
                .price(item.getPrice())
                .discount(item.getDiscount())
                .vat(item.getVat())
                .total(item.getTotal())
                .build()
        ).toList();

        return InvoiceDetailResponse.builder()
                .invoiceId(invoice.getId())
                .invoiceCode(invoice.getInvoiceCode())
                .patientName(invoice.getPatient().getFullName() + "-" + invoice.getPatient().getPatientCode())
                .confirmedAt(invoice.getConfirmedAt())
                .confirmedBy(invoice.getConfirmedBy() != null ? invoice.getConfirmedBy().getFullName() : null)
                .paymentType(invoice.getPaymentType())
                .total(invoice.getTotal())
                .originalTotal(invoice.getOriginalTotal())
                .discountTotal(invoice.getDiscountTotal())
                .vatTotal(invoice.getVatTotal())
                .items(itemResponses)
                .build();
    }

    @Override
    public BigDecimal sumTotalAmount(Map<String, String> filters) {
        Specification<Invoice> spec = InvoiceSpecification.buildSpecification(filters)
                .and((root, query, cb) -> cb.equal(root.get("status"), InvoiceStatus.PAID));

        List<Invoice> invoices = invoiceRepository.findAll(spec);
        return invoices.stream()
                .map(Invoice::getTotal)
                .filter(Objects::nonNull)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }



    @Override
    public BigDecimal sumMonthlyRevenue() {
        LocalDate firstDayOfMonth = LocalDate.now().withDayOfMonth(1);
        LocalDateTime start = firstDayOfMonth.atStartOfDay();
        LocalDateTime end = LocalDate.now().withDayOfMonth(LocalDate.now().lengthOfMonth()).atTime(23, 59, 59);

        List<Invoice> invoices = invoiceRepository.findAllByCreatedAtBetweenAndStatusAndDeletedAtIsNull(
                start, end, InvoiceStatus.PAID);

        return invoices.stream()
                .map(Invoice::getTotal)
                .filter(Objects::nonNull)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }


    @Override
    public long countValidInvoices(Map<String, String> filters) {
        Specification<Invoice> spec = InvoiceSpecification.buildSpecification(filters).and(
                (root, query, cb) -> cb.equal(root.get("status"), InvoiceStatus.PAID)
        );
        return invoiceRepository.count(spec);
    }

    @Override
    public List<InvoiceResponse> getAllInvoices(Map<String, String> filters, String sortBy, String sortDir) {
        String sortColumn = (sortBy == null || sortBy.isBlank()) ? "createdAt" : sortBy;
        Sort sort = sortDir.equalsIgnoreCase("asc") ? Sort.by(sortColumn).ascending() : Sort.by(sortColumn).descending();

        Specification<Invoice> spec = InvoiceSpecification.buildSpecification(filters);

        List<Invoice> invoices = invoiceRepository.findAll(spec, sort);
        return invoices.stream()
                .map(invoiceMapper::toInvoiceResponse)
                .toList();
    }



    private String formatCurrency(BigDecimal number) {
        return NumberFormat.getInstance(new Locale("vi", "VN")).format(number);
    }
}
